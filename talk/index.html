<!DOCTYPE html>
<html>
<head>
<title>Practical Go Programming</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="font-size-adjustment" content="-1" />
<link rel="stylesheet" href="slidy.css"
 type="text/css" media="screen, projection, print" />
<script src="slidy.js" type="text/javascript"></script>
</head>
<body>

<div class="slide titlepage">
<h1>Practical Go Programming</h1>
<p>Andrew Gerrand</p>
<p>adg@golang.org</p>
<p>http://wh3rd.net/practical-go/</p>
<p><img src="bumper640x360.png"></p>
</ul>
</div>

<div class="slide">
<h1>What is Go?</h1>
<img src="gopher.png" style="float: right;">
<p>Go is a general-purpose programming language.</p>
<p>Go's killer features:</p>
<ul class="contrasts">
<li>Emphasis on simplicity; <em>easy to learn</em></li>
<li>Memory managed and syntactically lightweight; <em>easy to use</em></li>
<li>Fast compiled code; <em>comparable to C</em></li>
<li>Concurrency support; <em>write simpler code</em></li>
<li>Static typing</li>
<li>Consistent standard library</li>
<li>Self-documenting (and well-documented)</li>
</ul>
</div>

<div class="slide">
<h1>This talk</h1>
<p>
This talk will cover the complete development of a simple web application.
</p>
<p>
There's a lot to cover, so we'll move pretty fast.
</p>
<p>
If you're new to Go there may be some syntax you don't understand.
The important thing is to get a feel for what the program does,
rather than exactly how it does it.
</p>
<p>
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a> - you may want to follow along.
</p>
<p>
Complete source code and other bits are available in the git repository:
<a href="http://github.com/nf/goto">http://github.com/nf/goto</a>
</p>
<p>
Twitter stuff:
</p>
<ul>
<li><code>#golang</code> hashtag
<li><code>@go_nuts</code> (that's me!)
</ul>
</div>

<div class="slide">
<h1>Let's write a Go program</h1>
<h3>goto: A URL Shortener</h3>
<p>Goto is a web service (HTTP) that does two things:</p>
<ul>
<li>When provided with a long URL, goto returns a short version:
	<p class="eg">
		http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q=tokyo&sll=37.0625,-95.677068&sspn=68.684234,65.566406&ie=UTF8&hq=&hnear=Tokyo,+Japan&t=h&z=9<br><br>
		http://goo.gl/UrcGq
	</p>
<li>When a shortened URL is requested, it redirects the user to the original, long URL.
</ul>
</div>

<div class="slide">
<h1>Data structures</h1>
<p>Goto maps short URLs to long URLs. To store this mapping in memory we can 
   use a hash table.</p>
<p>Go's <code>map</code> type allows you to map values of any* type
   to values of any other type.</p>
<p>Maps must be initialized with the built-in <code>make</code> function:</p>
<pre>
m := make(map[int]string)

m[1] = "One"

u := m[1]
<span>// u == "One"</span>

v, present := m[2]
<span>// v == "", present == false</span>
</pre>
<p>(*The keys must be comparable with <code>==</code>.)</p>
</div>

<div class="slide">
<h1>Data structures</h1>
<p>We specify the <code>URLStore</code> type,
Goto's fundamental data structure:</p>
<pre>
type URLStore map[string]string

m := make(URLStore)
</pre>
<p>To store the mapping of <code>http://goto/a</code> to <code>http://google.com/</code> in <code>m</code>:</p>
<pre>
m["a"] = "http://google.com/"

url := m["a"]
<span>// url == "http://google.com/"</span>
</pre>
<p>
This has a shortcoming: Go's <code>map</code> type is not thread-safe. 
</p>
<p>
Goto will serve many requests concurrently, so we must make our 
<code>URLStore</code> type safe to access from separate threads.
</p>
</div>

<div class="slide">
<h1>Adding a lock</h1>
<p>
To protect the <code>map</code> type from being modified while it is being
read, we must add a lock to the data structure.
</p>
<p>
Changing the type definition, we make <code>URLStore</code> a
<code>struct</code> type with two fields: the <code>map</code> and 
a <code>RWMutex</code> from the <code>sync</code> package.
</p>
<pre>
import "sync"

type URLStore struct {
	urls map[string]string
	mu   sync.RWMutex
}
</pre>
<p>
An <code>RWMutex</code> has two locks: one for readers, and one for writers.
Many clients can take the read lock simultaneously, but only one client can
take the write lock (to the exclusion of all readers).
</p>
</div>

<div class="slide">
<h1>Setter and Getter methods</h1>
<p>
We must now interact with the <code>URLStore</code> through <code>Set</code>
and <code>Get</code> methods.
</p>
<p>
The <code>Get</code> method takes the read lock with <code>RLock</code>, and
returns the URL as a string. If the key is present in the map, the
zero value for the string type (an empty string) will be returned.
</p>
<pre>
func (s *URLStore) Get(key string) string {
	s.mu.RLock()
	url := s.urls[key]
	s.mu.RUnlock()
        return url
}
</pre>
<p>
The <code>Set</code> method takes the write lock and updates the url map.
If the key is already present a boolean <code>false</code> value is
returned and the map is not updated.
</p>
<pre>
func (s *URLStore) Set(key, url string) bool {
	s.mu.Lock()
	_, present := s.urls[key]
	if present {
		s.mu.Unlock()
		return false
	}
	s.urls[key] = url
	s.mu.Unlock()
	return true
}       
</pre>
</div>

<div class="slide">
<h1>Defer: an aside</h1>
<p>
A <code>defer</code> statement pushes a function call onto a list.
The list of saved calls is executed after the surrounding function returns.
Defer is commonly used to simplify functions that perform various clean-up
actions.
</p>
<p>
For example, this function will print "Hello" and then "World":
<pre>
func foo() {
	defer fmt.Println("World")
	fmt.Println("Hello")
}
</pre>
<p>
We can use <code>defer</code> to simplify the <code>Set</code> and
<code>Get</code> methods.
</p>
<p class="eg">
There's more to defer.
See the "<a href="http://blog.golang.org/2010/08/defer-panic-and-recover.html">Defer, Panic, and Recover</a>" blog post for an in-depth discussion.
</p>
</div>

<div class="slide">
<h1>Setter and Getter methods</h1>
<p>
The <code>Get</code> method can avoid using the local <code>url</code>
variable and return the map value directly:
</p>
<pre>
func (s *URLStore) Get(key string) string {
	s.mu.RLock()
	<em>defer</em> s.mu.RUnlock()
	return s.urls[key]
}
</pre>
<p>
And the logic for <code>Set</code> becomes clearer:
</p>
<pre>
func (s *URLStore) Set(key, url string) bool {
	s.mu.Lock()
	<em>defer</em> s.mu.Unlock()
	_, present := s.urls[key]
	if present {
		return false
	}
	s.urls[key] = url
	return true
}       
</pre>
</div>

<div class="slide">
<h1>An initializer function</h1>
<p>
The <code>URLStore</code> struct contains a <code>map</code> field,
which must be initialized with <code>make</code> before it can be used.
<pre>
type URLStore struct {
	urls map[string]string
	mu   sync.RWMutex
}
</pre>
<p>
Go doesn't have constructors. Instead, the convention is to write a function
named <code>NewXXX</code> that returns an intialized instance of the type.
</p>
<pre>
func NewURLStore() *URLStore {
	return &URLStore{urls: make(map[string]string)}
}
</pre>
</div>

<div class="slide">
<h1>Using URLStore</h1>
<p>
Creating an instance:
</p>
<pre>
s := NewURLStore()
</pre>
<p>Setting a URL by key:</p>
<pre>
s.Set("a", "http://google.com")
</pre>
<p>Getting a URL by key:</p>
<pre>
if url := s.Get("a"); url != "" {
	// redirect to url
} else {
	// key not found
}
</pre>
</div>

<div class="slide">
<h1>Shortening URLs</h1>
<p>
We have the <code>Get</code> method for retrieving URLs.
Let's create a <code>Put</code> method that takes a URL,
stores the URL in the map under a corresponding key, and returns the key.
</p>
<pre>
type URLStore struct {
	<span>...</span>
	count int
}

func (s *URLStore) Put(url string) string {
        for {
                key := genKey(s.count)
                s.count++
                if ok := s.Set(key, url); ok {
                        return key
                }
        }
	return ""
}
</pre>
<p>
The <code>genKey</code> function takes an integer and returns a corresponding
alphanumeric key:
</p>
<pre>
func genKey(n int) string { <span>/* implementation omitted */ </span> }
</pre>
</div>

<!-- show the audience the complete store.go code now -->

<div class="slide">
<h1>HTTP Server</h1>
<p>
Go's <code>http</code> package provides the infrastructure to serve HTTP
requests:
</p>
<pre>
package main

import (
	"fmt"
	"http"
)

func Hello(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hello, world!")
}

func main()  {
	http.HandleFunc("/", Hello)
	http.ListenAndServe(":8080", nil)
}
</pre>
</div>

<!-- demo this working http server -->

<div class="slide">
<h1>HTTP Handlers</h1>
<p>
Goto has two HTTP handlers:
</p>
<ul>
<li><code>Redirect</code>, which redirects short URL requests, and
<li><code>Add</code>, which handles the submission of new URLs.
</ul>
<p>
The <code>HandleFunc</code> function is used to register them with the
<code>http</code> package.
</p>
<pre>
func main()  {
	http.HandleFunc("/", Redirect)
	http.HandleFunc("/add", Add)
	http.ListenAndServe(":8080", nil)
}
</pre>
<p>
Requests to <code>/add</code> will be served by the <code>Add</code> handler.<br>
All other requests will be served by the <code>Redirect</code> handler.
</div>

<div class="slide">
<h1>HTTP Handlers: Add</h1>
<p>
The <code>Add</code> function reads the <code>url</code>
parameter from an HTTP request, <code>Put</code>s it into
the <code>store</code>, and sends the corresponding short URL to the user.
</p>
<pre>
func Add(w http.ResponseWriter, r *http.Request) {
	url := r.FormValue("url")
	key := store.Put(url)
	fmt.Fprintf(w, "http://localhost:8080/%s", key)
}
</pre>
<p>
But what is <code>store</code>?
It's a global variable pointing to an intantiation of <code>URLStore</code>:
</p>
<pre>
var store = NewURLStore()
</pre>
<p>
The line above can appear anywhere in the top level of a source file.
It will be evaluated at program initialization, before the <code>main</code>
function is called.
</p>
</div>

<div class="slide">
<h1>HTTP Handlers: Add</h1>
<p>
What about the user interface? Let's modify <code>Add</code> to display an 
HTML form when no <code>url</code> is supplied:
</p>
<pre>
func Add(w http.ResponseWriter, r *http.Request) {
	url := r.FormValue("url")
<em>	if url == "" {
		fmt.Fprint(w, AddForm)
		return
	}</em>
	key := store.Put(url)
	fmt.Fprintf(w, "http://localhost:8080/%s", key)
}

<em>const AddForm = `
&lt;form method="POST" action="/add"&gt;
URL: &lt;input type="text" name="url"&gt;
&lt;input type="submit" value="Add"&gt;
&lt;/form&gt; 
`</em>
</div>

<div class="slide">
<h1>HTTP Handlers: Redirect</h1>
<p>
The <code>Redirect</code> function finds the key in the HTTP request path,
retrieves the corresponding URL from the <code>store</code>,
and sends an HTTP redirect to the user.
If the URL is not found, a 404 "Not Found" error is sent instead.
</p>
<pre>
func Redirect(w http.ResponseWriter, r *http.Request) {
	key := r.URL.Path[1:]
	url := store.Get(key)
	if url == "" {
		http.NotFound(w, r)
		return
	}
	http.Redirect(w, r, url, http.StatusFound)
}
</pre>
<p>
The <code>key</code> is the request path minus the first character.
For the request "<code>/foo</code>" the key would be "<code>foo</code>".
</p>
<p>
<code>http.NotFound</code> and <code>http.Redirect</code> are helpers for
sending common HTTP responses.  The constant <code>http.StatusFound</code>
represents HTTP code 302 ("Found").
</p>
</div>

<div class="slide">
<h1>Demonstration</h1>
<p>We've written under 100 lines of code, and have a complete,
   functional web application.</p>
<p>See the code we've written so far:</p>
<ul>
<li><a href="https://github.com/nf/goto/tree/master/talk/code/0/">https://github.com/nf/goto/tree/master/talk/code/0/</a></li>
</ul>
<!-- TODO: new diagram -->
<p>
The <code>http</code> package uses Go's concurrency features 
"behind the scenes". We will use goroutines and channels explicitly later.
</p>
<p class="eg">
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a>
</p>
</div>

<div class="slide">
<h1>Interfaces: an aside</h1>
<p>
Go's interface types define a set of methods. Any type that implements those
methods satisfies that interface.
</p>
<p>
One frequently-used interface is <code>Writer</code>, specified by the 
<code>io</code> package:
</p>
<pre>
type Writer interface {
	Write(p []byte) (n int, err os.Error)
}
</pre>
<p>
Many types, from both the standard library and other Go code, implement the
<code>Write</code> method described above, and can thus be used anywhere an
<code>io.Writer</code> is expected.
</p>
</div>

<div class="slide">
<h1>Interfaces: an aside</h1>
<p>
In fact, we've already used an <code>io.Writer</code> in our 
HTTP handlers:
</p>
<pre>
func Add(w http.ResponseWriter, r *http.Request) {
<span>	...</span>
	fmt.Fprintf(w, "http://localhost:8080/%s", key)
}
</pre>
<p>
The <code>Fprintf</code> function expects an <code>io.Writer</code> as its
first argument:
</p>
<pre>
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, error os.Error)
</pre>
<p>
Because <code>http.ResponseWriter</code> implements the <code>Write</code>
method, <code>w</code> can be passed to <code>Fprint</code> as an
<code>io.Writer</code>.
</p>
<p>
</div>

<div class="slide">
<h1>Persistent Storage</h1>
<p>
When the goto process ends, the shortened URLs in memory will be lost.
</p>
<p>
This isn't very helpful.
</p>
<p>
Let's modify <code>URLStore</code> so that it writes its <code>URLMap</code> to
a file, and restores that data on start-up.
</p>
</div>

<div class="slide">
<h1>Persistent Storage: gob</h1>
<p>
How should we represent the <code>URLMap</code> on disk?
</p>
<p>
Go's <code>gob</code> package handles serializing and deserializing Go
data structures.<br>
(Similar to Python's "pickle" or Java's "Serialization".)
</p>
<p>
The <code>gob</code> package's <code>NewEncoder</code> and
<code>NewDecoder</code> functions wrap <code>io.Writer</code> and
<code>io.Reader</code> values respectively.
</p>
<p>
The resulting <code>Encoder</code> and <code>Decoder</code> objects provide 
<code>Encode</code> and <code>Decode</code> methods for writing and reading
Go data structures.
</p>
</div>

<div class="slide">
<h1>Persistent Storage: URLMap</h1>
<p>
The <code>WriteTo</code> method writes the URLMap's data to the provided <code>io.Writer</code>:
</p>
<pre>
func (m *URLMap) WriteTo(w io.Writer) os.Error {
	m.mu.RLock()
	e := gob.NewEncoder(w)
	err := e.Encode(m.urls)
	m.mu.RUnlock()
	return err
}
</pre>
</ul>
</div>

<div class="slide">
<h1>Persistent Storage: URLMap</h1>
<p>
The <code>ReadFrom</code> method reads URLMap data from the provided <code>io.Reader</code>:
</p>
<pre>
func (m *URLMap) ReadFrom(r io.Reader) os.Error {
	m.mu.Lock()
	d := gob.NewDecoder(r)
	err := d.Decode(&m.urls)
	m.mu.Unlock()
	return err
}
</pre>
</div>

<div class="slide">
<h1>Persistent Storage: URLMap</h1>
<pre>
func (m *URLMap) WriteTo(w io.Writer) os.Error {
	m.mu.RLock()
	<em>defer</em> m.mu.RUnlock()
	e := gob.NewEncoder(w)
	return e.Encode(m.urls)
}

func (m *URLMap) ReadFrom(r io.Reader) os.Error {
	m.mu.Lock()
	<em>defer</em> m.mu.Unlock()
	d := gob.NewDecoder(r)
	return d.Decode(&m.urls)
}
</pre>
<p>
Using <code>defer</code>, we remove the need for the local variable
<code>err</code>. The mutexes are unlocked <em>after</em> the return statements.
</p>
</div>

<div class="slide">
<h1>Persistent Storage: URLStore</h1>
<p>
Now that we have a means of reading and writing <code>URLMap</code> data, 
we can make <code>URLStore</code> load and save data from files.
</p>
<p>
First, we'll add a <code>filename</code> element to the <code>URLStore</code>
struct, and add a <code>filename</code> parameter to the
<code>NewURLStore</code> function:
</p>
<pre>
type URLStore struct {
	mu       sync.Mutex
	urls     *URLMap
	count    int
<em>	filename string</em>
}

func NewURLStore(<em>filename string</em>) *URLStore {
	return &URLStore{
		urls:     NewURLMap(),
<em>		filename: filename,</em>
	}
}
</pre>
</div>

<div class="slide">
<h1>Persistent Storage: URLStore</h1>
<p>
The <code>load</code> method opens a file and reads its contents
into the <code>URLMap</code>.
</p>
<pre>
func (s *URLStore) load() os.Error {
	f, err := os.Open(s.filename, os.O_RDONLY, 0)
	if err != nil {
		return err
	}
	defer f.Close()
	return s.urls.ReadFrom(f)
}
</pre>
<p>The variable <code>f</code> is an <code>*os.File</code>, which implements
the <code>Read</code> method and can therefore be used as an
<code>io.Reader</code> by <code>ReadFrom</code>.
</div>

<div class="slide">
<h1>Persistent Storage: URLStore</h1>
<p>
The <code>save</code> method opens a file for writing (either creating or
truncating it) and writes the contents of the <code>URLMap</code> to it.
</p>
<pre>
func (s *URLStore) save() os.Error {
	f, err := os.Open(s.filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer f.Close()
	return s.urls.WriteTo(f)
}
</pre>
<p>Again, the variable <code>f</code> is an <code>*os.File</code>, which also
implements the <code>Write</code> method and can therefore be used as an
<code>io.Writer</code> by <code>WriteTo</code>.
</div>

<div class="slide">
<h1>Persistent Storage: URLStore</h1>
<p>
Now we can make it <code>load</code> when initializing the
<code>URLStore</code>:
</p>
<pre>
func NewURLStore(filename string) *URLStore {
	s := &URLStore{
		urls:     NewURLMap(),
		filename: filename,
	}
<em>	if err := s.load(); err != nil {
		log.Println("URLStore:", err)
	}</em>
	return s
}
</pre>
</div>
<div class="slide">
<h1>Persistent Storage: URLStore</h1>
<p>And <code>save</code> when a new URL is added:</p>
<pre>
func (s *URLStore) Put(url string) (key string) {
<span>	... (generate key)</span>
        s.urls.Set(key, url)
<em>	if err := s.save(); err != nil {
		log.Println("URLStore:", err)
	}</em>
	s.mu.Unlock()
	return
}
</pre>
</div>

<div class="slide">
<h1>Persistent Storage</h1>
<p>
Finally, we must specify a filename when instantiating the URLStore:
</p>
<pre>
var store = NewURLStore(<em>"store.gob"</em>)
</pre>

<h1>Demonstration</h1>
<p>See the code we've written so far:</p>
<ul>
<li><a href="https://github.com/nf/goto/tree/master/talk/code/1/">https://github.com/nf/goto/tree/master/talk/code/1/</a></li>
</ul>
<p class="eg">
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a>
</p>
</div>

<div class="slide">
<h1>A point of contention</h1>
<p>
Consider this pathological situation:
</p>
<ul>
<li>Many clients attempt to add URLs simultaneously.
<li>Each client must obtain the <code>URLStore</code> lock to perform a <code>Put</code>.
<li>The <code>URLMap</code> is written to disk during each <code>Put</code>
    (while the lock is held).
<li>Therefore, the <i>n</i>th client must wait for the <code>URLMap</code>
    to be written to disk <i>n</i>-1 times before its <code>Put</code> can 
    complete.
</ul>
<p>
To improve this situation we should decouple the <code>save</code> process 
from the <code>Put</code> process, and only <code>save</code> the 
<code>URLMap</code> periodically.
</p>
</div>

<div class="slide">
<h1>Goroutines: an aside</h1>
<p>A <i>goroutine</i> is a lightweight thread managed by the Go runtime.</p>
<p>Goroutines are launched by a <code>go</code> statement. This code executes
both <code>foo</code> and <code>bar</code> concurrently:</p>
<pre>
go foo()
bar()
</pre>
<p>
The <code>foo</code> function runs in a newly created goroutine, while
<code>bar</code> runs in the main goroutine.
</p>
<p>
Memory is shared between goroutines, like in many popular threading models.
</p>
<p>
Goroutines are cheaper to create than operating system threads.
</p>
</div>

<div class="slide">
<h1>Saving on the side</h1>
<p>
Let's create a function that will run in its own goroutine, periodically saving
the data store.
</p>
<pre>
const saveTimeout = 10e9 // 10 seconds in nanoseconds

func (s *URLStore) saveLoop() {
	for {
		if err := s.save(); err != nil {
			log.Println("URLStore:", err)
		}
		time.Sleep(saveTimeout)
	}
}
</pre>
</div>

<div class="slide">
<h1>Saving on the side</h1>
<p>
We then need to launch the goroutine from <code>NewURLStore</code>:
</p>
<pre>
func NewURLStore(filename string) *URLStore {
	s := &URLStore{
		urls:     NewURLMap(),
		filename: filename,
	}
	if err := s.load(); err != nil {
		log.Println("URLStore:", err)
	}
<em>	go s.saveLoop()</em>
	return s
}
</pre>
<p class="eg">
(And we shouldn't forget to remove the call to <code>save</code> from the
<code>Put</code> method.)
</p>
<div class="incremental">
<p>
But there's a problem with this approach: <code>save</code> will be called 
regardless of whether the data store has been modified. This causes a lot of
needless disk churn, and may become problematic as the data set grows.
</p>
<p>
We need to send a signal to the <code>saveLoop</code> to tell it when
the data needs to be saved.
</p>
</div>
</div>

<div class="slide">
<h1>Channels: an aside</h1>
<p>
A <i>channel</i> is a conduit, like a unix pipe, through which you can send
typed values. They provide many interesting algorithmic possibilities.
</p>
<p>
Channels underpin the Go philosophy to concurrent programming:
</p>
<p><i>
Do not communicate by sharing memory; instead, share memory by communicating.
</i></p>
<p>
Like maps, channels must be initialized with <code>make</code>:
</p>
<pre>
ch := make(chan int) // a channel of ints
</pre>
<p>
Communication is expressed using the "channel operator", <code>&lt;-</code> :
<p>
<pre>
ch &lt;- 7   // send the int 7 to the channel

i := &lt;-ch // receive an int from the channel
</pre>
</div>

<div class="slide">
<h1>Channels: an aside</h1>
<p>
Channel send/receive operations typically block until the other side is ready.
Channels can be either buffered or unbuffered.
Sends to a buffered channel will not block until the buffer is full.
</p>
<p>
Buffered channels are initialized by specifying the buffer size as the 
second argument to <code>make</code>:
</p>
<pre>
ch := make(chan int, 10)
</pre>
<p>
Non-blocking sends are performed by treating the send statement as
an expression:
</p>
<pre>
ok := ch <- 1
<span>// ok == true if the send occurred</span>
</pre>
<p>
Similarly, you can perform non-blocking reads by taking the second return
value of the read:
</p>
<pre>
i, ok := <-ch
<span>// ok == true if a receive occurred</span>
</pre>
<p class="eg">
See the blog posts "<a href="http://blog.golang.org/2010/07/share-memory-by-communicating.html">Share Memory by Communicating</a>" and "<a href="http://blog.golang.org/2010/09/go-concurrency-patterns-timing-out-and.html">Timing out, moving on</a>" for a detailed discussion of goroutines and channels.
</p>
</div>

<div class="slide">
<h1>Saving on demand</h1>
<p>
We can use a channel of boolean values to tell <code>saveLoop</code> when
the data structure is "dirty", and a <code>save</code> is required.
</p>
<pre>
type URLStore struct {
	mu       sync.Mutex
	urls     *URLMap
	count    int
	filename string
<em>	dirty    chan bool</em>
}
</pre>
</div>

<div class="slide">
<h1>Saving on demand</h1>
<p>
Now we make <code>saveLoop</code> wait until a value is received from
<code>dirty</code> before saving.
<pre>
func (s *URLStore) saveLoop() {
	for {
<em>		<-s.dirty</em>
		if err := s.save(); err != nil {
			log.Println("URLStore:", err)
		}
		time.Sleep(saveTimeout)
	}
}
</pre>
<p>
Note that while <code>dirty</code> carries boolean values
(<code>true</code> or <code>false</code>), 
we're not actually concerned with the value itself.
It's the presence of <i>any</i> value, true or false, that tells
<code>saveLoop</code> when to <code>save</code>.
</p>
</div>

<div class="slide">
<h1>Saving on demand</h1>
<p>
We add a non-blocking send to the <code>Put</code> method:
</p>
<pre>
func (s *URLStore) Put(url string) (key string) {
<span>	... (generate key)</span>
        s.urls.Set(key, url)
	s.mu.Unlock()
<em>	_ = s.dirty <- true</em>
	return
}
</pre>
<p>
The <code>_</code> is a write-only variable; the value will be thrown away.
We don't care whether the message is received or not.
</p>
</div>

<div class="slide">
<h1>Saving on demand</h1>
<p>
We make <code>dirty</code> a buffered channel with space for just one value,
so that if a send occurs while <code>saveLoop</code> is busy 
(either saving or sleeping) the value will still be received when 
<code>saveLoop</code> becomes ready.
</p>
<pre>
func NewURLStore(filename string) *URLStore {
	s := &URLStore{
		urls:     NewURLMap(),
		filename: filename,
<em>		dirty:    make(chan bool, 1),</em>
	}
	if err := s.load(); err != nil {
		log.Println("URLStore:", err)
	}
	go s.saveLoop()
	return s
}
</pre>
</div>

<div class="slide">
<h1>Demonstration</h1>
<p>See the code we've written so far:</p>
<ul>
<li><a href="https://github.com/nf/goto/tree/master/talk/code/2/">https://github.com/nf/goto/tree/master/talk/code/2/</a></li>
</ul>
<p class="eg">
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a>
</p>
</div>

<div class="slide">
<h1>An aside: Command-line flags</h1>
<p>
Go's <code>flag</code> package makes it easy to handle command-line flags.
Let's use it to replace the constants we have littered through our code so
far.
</p>
<p>
We first create some global variables to hold the flag values:
</p>
<pre>
import (
<em>	"flag"</em>
	"fmt"
	"http"
)

var (
  listenAddr = flag.String("http", ":9980", "http listen address")
  dataFile   = flag.String("file", "store.gob", "data store file name")
  hostname   = flag.String("host", "localhost", "http host name")
)
</pre>
</div>

<div class="slide">
<h1>An aside: Command-line flags</h1>
<p>
Then we can add <code>flag.Parse()</code> to the <code>main</code> function,
and instantiate the <code>URLStore</code> after the flags have been parsed
(once we know the value of <code>*dataFile</code>).
</p>
<pre>
var store<em> *URLStore</em>

func main() {
<em>	flag.Parse()
	store = URLStore(*dataFile)</em>
        http.HandleFunc("/", Redirect)
        http.HandleFunc("/add", Add)
        http.ListenAndServe(<em>*listenAddr</em>, nil)
}
</pre>
<p>
And substitute <code>*hostname</code> in the <code>Add</code> handler:
</p>
<pre>
	fmt.Fprintf(w, "http://<em>%s</em>/%s", <em>*hostname,</em> key)
</pre>
</div>


<div class="slide">
<h1>One more thing...</h1>
<img src="balancer.png" style="float: right;">
<p>
So far we have a program that runs as a single process. But a single process
running on one machine can only serve so many concurrent requests.
</p>
<p>
A URL Shortener typically serves many more Redirects (reads) than it does
Adds (writes).
</p>
<p>
Therefore we can create an arbitrary number of read-only slaves that serve and
cache Get requests, and pass Puts through to the master.
</p>
</div>

<div class="slide">
<h1>RPC: an aside</h1>
<p>
Go's <code>rpc</code> package provides a convenient means of making function
calls over a network connection.
</p>
<p>
To serve, define a type with the methods you want to make accesible to RPC:
</p>
<pre>
type Args struct { A, B int }
type Arith struct{}
func (t *Arith) Multiply(args *Args, reply *int) os.Error {
	*reply = args.A * args.B
	return nil
}
</pre>
<p>
Then <code>Register</code> them with the <code>rpc</code> module, and start
an HTTP server (for RPC-over-HTTP).
</p>
<pre>
rpc.Register(new(Arith))
rpc.HandleHTTP()
http.ListenAndServe(":8080", nil)
</pre>
<p>
This makes the <code>Multiply</code> method available as an RPC call under the name
<code>"Arith.Multiply"</code>.
</div>

<div class="slide">
<h1>RPC: an aside</h1>
<p>
On the client side, dial the server:
</p>
<pre>
client, err := rpc.DialHTTP("tcp", "localhost:8080")
if err != nil {
	log.Exit("dialing:", err)
}
</pre>
<p>
Set up arguments and reply values, and make the RPC <code>Call</code>:
</p>
<pre>
args := Args{7,8}
var reply int
err = client.Call("Arith.Multiply", &args, &reply)
if err != nil {
	log.Exit("arith error:", err)
}
fmt.Printf("Arith: %d*%d=%d", args.A, args.B, *reply)
</pre>
</div>

<div class="slide">
<h1>Making URLStore an RPC service</h1>
<p>
To make <code>URLStore</code> an RPC services, we need to alter the 
<code>Get</code> and <code>Put</code> methods to be <code>rpc</code>-friendly.
The function signatures change, and now return an <code>os.Error</code> value.
</p>
<p>
The <code>Get</code> method can return an explicit error when the provided key 
is not found:
</p>
<pre>
func (s *URLStore) Get(key, url *string) <em>os.Error</em> {
<em>	if u := </em>s.urls.Get(*key)<em>; u != "" {
		*url = u
		return nil
	}
	return os.NewError("key not found")</em>
}
</pre>
<p>
Beyond the function signature, the <code>Put</code> method barely changes
in its actual code (not shown here):
</p>
<pre>
func (s *URLStore) Put(url, key *string) <em>os.Error</em>
</pre>
</div>

<div class="slide">
<h1>Making URLStore an RPC service</h1>
<p>
In turn, the HTTP handlers must be modfied to accommodate the changes to
<code>URLStore</code>.
</p>
<p>
The <code>Redirect</code> handler now returns the error string provided by
the <code>URLStore</code>:
</p>
<pre>
func Redirect(w http.ResponseWriter, r *http.Request) {
	key := r.URL.Path[1:]
<em>	var url string</em>
	if <em>err</em> := store.Get(<em>&</em>key, <em>&</em>url); err != nil {
<em>	        http.Error(w, err.String(), http.StatusInternalServerError)</em>
	        return
	}
	http.Redirect(w, r, url, http.StatusFound)
}
</pre>
</div>

<div class="slide">
<h1>Making URLStore an RPC service</h1>
<p>The <code>Add</code> handler changes in much the same way:</p>
<pre>
func Add(w http.ResponseWriter, r *http.Request) {
	url := r.FormValue("url")
	if url == "" {
	        fmt.Fprint(w, AddForm)
	        return
	}
<em>	var key string</em>
	if <em>err</em> := store.Put(<em>&</em>url, <em>&</em>key); err != nil {
<em>	        http.Error(w, err.String(), http.StatusInternalServerError)</em>
	        return
	}
	fmt.Fprintf(w, "http://%s/%s", *hostname, key)
}
</pre>
</div>

<div class="slide">
<h1>Making URLStore an RPC service</h1>
<p>Finally, we can register the <code>URLStore</code> as an <code>rpc</code>
service. First we'll add a command-line flag to enable it:</p>
<pre>
rpcEnabled = flag.Bool("rpc", false, "enable RPC server")
</pre>
<p>
And add the registration to <code>main</code>:
</p>
<pre>
func main() {
	flag.Parse()
	store = URLStore(*dataFile)
<em>	if *rpcEnabled {
	        rpc.RegisterName("Store", store)
	        rpc.HandleHTTP()
	}</em>
<span>	... (set up http)</span>
}
</pre>
</div>

<div class="slide">
<h1>ProxyStore</h1>
<p>
Now that we have the URLStore available as an RPC service, we can build
another type that has the <code>Get</code> and <code>Put</code> methods of
the <code>URLStore</code>, but instead forwards requests to the RPC server.
</p>
<p>
We will call it <code>ProxyStore</code>:
</p>
<pre>
type ProxyStore struct {
        client *rpc.Client
}

func NewProxyStore(addr string) *ProxyStore {
        client, err := rpc.DialHTTP("tcp", addr)
        if err != nil {
                log.Println("ProxyStore:", err)
        }
        return &ProxyStore{client: client}
}
</pre>
</div>

<div class="slide">
<h1>ProxyStore</h1>
<p>
Its <code>Get</code> and <code>Put</code> methods pass the requests directly
to the RPC server:
</p>
<pre>
func (s *ProxyStore) Get(key, url *string) os.Error {
        return s.client.Call("Store.Get", key, url)
}

func (s *ProxyStore) Put(url, key *string) os.Error {
        return s.client.Call("Store.Put", url, key)
}
</pre>
</div>

<div class="slide">
<h1>Integrating ProxyStore</h1>
<p>
Now we want to be able to use <code>ProxyStore</code> with the web front-end,
in the place of <code>URLStore</code>.
</p>
<p>
Since they both implement the same <code>Get</code> and <code>Put</code>
methods, we can specify an interface to generalize their behavior:
</p>
<pre>
type Store interface {
        Put(url, key *string) os.Error
        Get(key, url *string) os.Error
}
</pre>
<p>
Now our global variable <code>store</code> can be of type <code>Store</code>:
</p>
<pre>
var store Store
</pre>
</div>

<div class="slide">
<h1>Integrating ProxyStore</h1>
<p>
Our <code>main</code> function can instantiate either a <code>URLStore</code>
or <code>ProxyStore</code> depending on a new command-line flag:
</p>
<pre>
masterAddr = flag.String("master", "", "RPC master address")
</pre>
<pre>
func main() {
        flag.Parse() 
        if *masterAddr != "" {
                store = NewProxyStore(*masterAddr)
        } else {
                store = NewURLStore(*dataFile)
        }
<span>	...</span>
}
</pre>
<p>
The rest of the front-end code continues to work as before.
It need not be aware of the <code>Store</code> interface.
</p>
</div>

<div class="slide">
<h1>Demonstration</h1>
<p>
Now we can watch requests being passed from the slave to the master.
</p>
<p>
But there's something missing: the slave must cache the data it 
gets from the master, otherwise it provides no benefit.
</p>
<p class="eg">
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a>
</p>
</div>

<div class="slide">
<h1>A caching ProxyStore</h1>
<p>
We already have the perfect data structure for caching this data, the
<code>URLMap</code>.
</p>
<p>
Let's add a <code>URLMap</code> instance to <code>ProxyStore</code>:
</p>
<pre>
type ProxyStore struct {
<em>	urls   *URLMap</em>
	client *rpc.Client
}

func NewProxyStore(addr string) *ProxyStore {
	client, err := rpc.DialHTTP("tcp", addr)
	if err != nil {
	        log.Println("ProxyStore:", err)
	}
	return &ProxyStore{<em>urls: NewURLMap()</em>, client: client}
}
</pre>
</div>

<div class="slide">
<h1>A caching ProxyStore</h1>
<p>
The <code>Get</code> method should first check if the key is in the cache.
If present, <code>Get</code> should return the cached result. If not,
it should make the RPC call, and update its local cache with the result.
</p>
<pre>
func (s *ProxyStore) Get(key, url *string) os.Error {
<em>	if u := s.urls.Get(*key); u != "" {
	        *url = u
	        return nil
	}</em>
	err := s.client.Call("Store.Get", key, url)
<em>	if err == nil {
	        s.urls.Set(*key, *url)
	}</em>
	return err
}
</pre>
</div>

<div class="slide">
<h1>A caching ProxyStore</h1>
<p>
The <code>Put</code> method need only update the cache when it performs a
successful RPC <code>Put</code>.
</p>
<pre>
func (s *ProxyStore) Put(url, key *string) os.Error {
	err := s.client.Call("Store.Put", url, key)
<em>	if err == nil {
	        s.urls.Set(*key, *url)
	}</em>
	return err
}
</pre>
</div>

<div class="slide">
<h1>Final demonstration</h1>
<p>
Now we can launch a master and several slaves, and stress-test the slaves.
</p>
<p>See the complete program:</p>
<ul>
<li><a href="https://github.com/nf/goto/tree/master/talk/code/3/">https://github.com/nf/goto/tree/master/talk/code/3/</a></li>
</ul>
<p class="eg">
These slides are available at <a href="http://wh3rd.net/practical-go/">http://wh3rd.net/practical-go/</a>
</p>
</div>

<div class="slide">
<h1>Exercises for the reader (or listener)</h1>
<p>
While this program does what we set out to do, there are a few ways it could
be improved:
</p>
<ul>
<li>Aesthetics: the user interface could be (much) prettier. 
    See the <a href="http://golang.org/doc/codelab/wiki/">Wiki Codelab</a>
    for details on using Go's <code>template</code> package.
<li>Reliability: the master/slave RPC connections could be more reliable.
    If the client-server connection goes down,
    the client should attempt to re-dial.
    A "dialer" goroutine could manage this.
<li>Resource exhaustion: as the size of the URL database grows, memory usage
    might become an issue. This could be resolved by sharding the master 
    servers by key.
<li>Deletion: to support deletion of shortened URLs, the interactions 
    bewteen master and slave would need to be made more complex.
<li>Storage: rather than re-writing the whole database on each call to
    <code>save</code>, it would be more efficient to write each new URL to
    disk incrementally.
</ul>
</div>

<div class="slide titlepage">
<h1>Questions?</h1>
<p>Andrew Gerrand</p>
<p>adg@golang.org</p>
<p>http://wh3rd.net/practical-go/</p>
<p><img src="bumper640x360.png"></p>
</div>

</body>
</html>
 
